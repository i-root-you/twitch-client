package obsws

import (
	"errors"
	"time"
)

// This file is automatically generated.
// https://github.com/christopher-dG/go-obs-websocket/blob/master/codegen/protocol.py

// GetSourcesListRequest : List all sources available in the running OBS instance.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getsourceslist
type GetSourcesListRequest struct {
	_request `json:",squash"`
	response chan GetSourcesListResponse
}

// NewGetSourcesListRequest returns a new GetSourcesListRequest.
func NewGetSourcesListRequest() GetSourcesListRequest {
	return GetSourcesListRequest{
		_request{
			ID_:   getMessageID(),
			Type_: "GetSourcesList",
			err:   make(chan error, 1),
		},
		make(chan GetSourcesListResponse, 1),
	}
}

// Send sends the request.
func (r *GetSourcesListRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSourcesListResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSourcesListRequest) Receive() (GetSourcesListResponse, error) {
	if !r.sent {
		return GetSourcesListResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourcesListResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourcesListResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSourcesListResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSourcesListRequest) SendReceive(c Client) (GetSourcesListResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSourcesListResponse{}, err
	}
	return r.Receive()
}

// GetSourcesListResponse : Response for GetSourcesListRequest.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getsourceslist
type GetSourcesListResponse struct {
	// Array of sources as objects.
	// Required: Yes.
	Sources []map[string]interface{} `json:"sources"`
	// Unique source name.
	// Required: Yes.
	SourcesName string `json:"sources.*.name"`
	// Non-unique source internal type (a.k.a type id).
	// Required: Yes.
	SourcesTypeID string `json:"sources.*.typeId"`
	// Source type.
	// Value is one of the following: "input", "filter", "transition", "scene" or "unknown".
	// Required: Yes.
	SourcesType string `json:"sources.*.type"`
	_response   `json:",squash"`
}

// GetSourcesTypesListRequest : Get a list of all available sources types.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getsourcestypeslist
type GetSourcesTypesListRequest struct {
	_request `json:",squash"`
	response chan GetSourcesTypesListResponse
}

// NewGetSourcesTypesListRequest returns a new GetSourcesTypesListRequest.
func NewGetSourcesTypesListRequest() GetSourcesTypesListRequest {
	return GetSourcesTypesListRequest{
		_request{
			ID_:   getMessageID(),
			Type_: "GetSourcesTypesList",
			err:   make(chan error, 1),
		},
		make(chan GetSourcesTypesListResponse, 1),
	}
}

// Send sends the request.
func (r *GetSourcesTypesListRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSourcesTypesListResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSourcesTypesListRequest) Receive() (GetSourcesTypesListResponse, error) {
	if !r.sent {
		return GetSourcesTypesListResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourcesTypesListResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourcesTypesListResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSourcesTypesListResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSourcesTypesListRequest) SendReceive(c Client) (GetSourcesTypesListResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSourcesTypesListResponse{}, err
	}
	return r.Receive()
}

// GetSourcesTypesListResponse : Response for GetSourcesTypesListRequest.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getsourcestypeslist
type GetSourcesTypesListResponse struct {
	// Array of sources as objects.
	// Required: Yes.
	IDs []map[string]interface{} `json:"ids"`
	// Non-unique internal source type ID.
	// Required: Yes.
	IDsTypeID string `json:"ids.*.typeId"`
	// Display name of the source type.
	// Required: Yes.
	IDsDisplayName string `json:"ids.*.displayName"`
	// Type.
	// Value is one of the following: "input", "filter", "transition" or "other".
	// Required: Yes.
	IDsType string `json:"ids.*.type"`
	// Default settings of this source type.
	// Required: Yes.
	IDsDefaultSettings map[string]interface{} `json:"ids.*.defaultSettings"`
	// Source type capabilities.
	// Required: Yes.
	IDsCaps map[string]interface{} `json:"ids.*.caps"`
	// True if source of this type provide frames asynchronously.
	// Required: Yes.
	IDsCapsIsAsync bool `json:"ids.*.caps.isAsync"`
	// True if sources of this type provide video.
	// Required: Yes.
	IDsCapsHasVideo bool `json:"ids.*.caps.hasVideo"`
	// True if sources of this type provide audio.
	// Required: Yes.
	IDsCapsHasAudio bool `json:"ids.*.caps.hasAudio"`
	// True if interaction with this sources of this type is possible.
	// Required: Yes.
	IDsCapsCanInteract bool `json:"ids.*.caps.canInteract"`
	// True if sources of this type composite one or more sub-sources.
	// Required: Yes.
	IDsCapsIsComposite bool `json:"ids.*.caps.isComposite"`
	// True if sources of this type should not be fully duplicated.
	// Required: Yes.
	IDsCapsDoNotDuplicate bool `json:"ids.*.caps.doNotDuplicate"`
	// True if sources of this type may cause a feedback loop if it's audio is monitored and shouldn't be.
	// Required: Yes.
	IDsCapsDoNotSelfMonitor bool `json:"ids.*.caps.doNotSelfMonitor"`
	_response               `json:",squash"`
}

// GetVolumeRequest : Get the volume of the specified source.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getvolume
type GetVolumeRequest struct {
	// Name of the source.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan GetVolumeResponse
}

// NewGetVolumeRequest returns a new GetVolumeRequest.
func NewGetVolumeRequest(source string) GetVolumeRequest {
	return GetVolumeRequest{
		source,
		_request{
			ID_:   getMessageID(),
			Type_: "GetVolume",
			err:   make(chan error, 1),
		},
		make(chan GetVolumeResponse, 1),
	}
}

// Send sends the request.
func (r *GetVolumeRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetVolumeResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetVolumeRequest) Receive() (GetVolumeResponse, error) {
	if !r.sent {
		return GetVolumeResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetVolumeResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetVolumeResponse{}, err
		case <-time.After(receiveTimeout):
			return GetVolumeResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetVolumeRequest) SendReceive(c Client) (GetVolumeResponse, error) {
	if err := r.Send(c); err != nil {
		return GetVolumeResponse{}, err
	}
	return r.Receive()
}

// GetVolumeResponse : Response for GetVolumeRequest.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getvolume
type GetVolumeResponse struct {
	// Name of the source.
	// Required: Yes.
	Name string `json:"name"`
	// Volume of the source.
	// Between `0.0` and `1.0`.
	// Required: Yes.
	Volume float64 `json:"volume"`
	// Indicates whether the source is muted.
	// Required: Yes.
	Mute      bool `json:"mute"`
	_response `json:",squash"`
}

// SetVolumeRequest : Set the volume of the specified source.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#setvolume
type SetVolumeRequest struct {
	// Name of the source.
	// Required: Yes.
	Source string `json:"source"`
	// Desired volume.
	// Must be between `0.0` and `1.0`.
	// Required: Yes.
	Volume   float64 `json:"volume"`
	_request `json:",squash"`
	response chan SetVolumeResponse
}

// NewSetVolumeRequest returns a new SetVolumeRequest.
func NewSetVolumeRequest(
	source string,
	volume float64,
) SetVolumeRequest {
	return SetVolumeRequest{
		source,
		volume,
		_request{
			ID_:   getMessageID(),
			Type_: "SetVolume",
			err:   make(chan error, 1),
		},
		make(chan SetVolumeResponse, 1),
	}
}

// Send sends the request.
func (r *SetVolumeRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetVolumeResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetVolumeRequest) Receive() (SetVolumeResponse, error) {
	if !r.sent {
		return SetVolumeResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetVolumeResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetVolumeResponse{}, err
		case <-time.After(receiveTimeout):
			return SetVolumeResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetVolumeRequest) SendReceive(c Client) (SetVolumeResponse, error) {
	if err := r.Send(c); err != nil {
		return SetVolumeResponse{}, err
	}
	return r.Receive()
}

// SetVolumeResponse : Response for SetVolumeRequest.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#setvolume
type SetVolumeResponse struct {
	_response `json:",squash"`
}

// GetMuteRequest : Get the mute status of a specified source.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getmute
type GetMuteRequest struct {
	// The name of the source.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan GetMuteResponse
}

// NewGetMuteRequest returns a new GetMuteRequest.
func NewGetMuteRequest(source string) GetMuteRequest {
	return GetMuteRequest{
		source,
		_request{
			ID_:   getMessageID(),
			Type_: "GetMute",
			err:   make(chan error, 1),
		},
		make(chan GetMuteResponse, 1),
	}
}

// Send sends the request.
func (r *GetMuteRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetMuteResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetMuteRequest) Receive() (GetMuteResponse, error) {
	if !r.sent {
		return GetMuteResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetMuteResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetMuteResponse{}, err
		case <-time.After(receiveTimeout):
			return GetMuteResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetMuteRequest) SendReceive(c Client) (GetMuteResponse, error) {
	if err := r.Send(c); err != nil {
		return GetMuteResponse{}, err
	}
	return r.Receive()
}

// GetMuteResponse : Response for GetMuteRequest.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getmute
type GetMuteResponse struct {
	// The name of the source.
	// Required: Yes.
	Name string `json:"name"`
	// Mute status of the source.
	// Required: Yes.
	Muted     bool `json:"muted"`
	_response `json:",squash"`
}

// SetMuteRequest : Sets the mute status of a specified source.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#setmute
type SetMuteRequest struct {
	// The name of the source.
	// Required: Yes.
	Source string `json:"source"`
	// Desired mute status.
	// Required: Yes.
	Mute     bool `json:"mute"`
	_request `json:",squash"`
	response chan SetMuteResponse
}

// NewSetMuteRequest returns a new SetMuteRequest.
func NewSetMuteRequest(
	source string,
	mute bool,
) SetMuteRequest {
	return SetMuteRequest{
		source,
		mute,
		_request{
			ID_:   getMessageID(),
			Type_: "SetMute",
			err:   make(chan error, 1),
		},
		make(chan SetMuteResponse, 1),
	}
}

// Send sends the request.
func (r *SetMuteRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetMuteResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetMuteRequest) Receive() (SetMuteResponse, error) {
	if !r.sent {
		return SetMuteResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetMuteResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetMuteResponse{}, err
		case <-time.After(receiveTimeout):
			return SetMuteResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetMuteRequest) SendReceive(c Client) (SetMuteResponse, error) {
	if err := r.Send(c); err != nil {
		return SetMuteResponse{}, err
	}
	return r.Receive()
}

// SetMuteResponse : Response for SetMuteRequest.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#setmute
type SetMuteResponse struct {
	_response `json:",squash"`
}

// ToggleMuteRequest : Inverts the mute status of a specified source.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#togglemute
type ToggleMuteRequest struct {
	// The name of the source.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan ToggleMuteResponse
}

// NewToggleMuteRequest returns a new ToggleMuteRequest.
func NewToggleMuteRequest(source string) ToggleMuteRequest {
	return ToggleMuteRequest{
		source,
		_request{
			ID_:   getMessageID(),
			Type_: "ToggleMute",
			err:   make(chan error, 1),
		},
		make(chan ToggleMuteResponse, 1),
	}
}

// Send sends the request.
func (r *ToggleMuteRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp ToggleMuteResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r ToggleMuteRequest) Receive() (ToggleMuteResponse, error) {
	if !r.sent {
		return ToggleMuteResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return ToggleMuteResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return ToggleMuteResponse{}, err
		case <-time.After(receiveTimeout):
			return ToggleMuteResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r ToggleMuteRequest) SendReceive(c Client) (ToggleMuteResponse, error) {
	if err := r.Send(c); err != nil {
		return ToggleMuteResponse{}, err
	}
	return r.Receive()
}

// ToggleMuteResponse : Response for ToggleMuteRequest.
//
// Since obs-websocket version: 4.0.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#togglemute
type ToggleMuteResponse struct {
	_response `json:",squash"`
}

// SetSyncOffsetRequest : Set the audio sync offset of a specified source.
//
// Since obs-websocket version: 4.2.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#setsyncoffset
type SetSyncOffsetRequest struct {
	// The name of the source.
	// Required: Yes.
	Source string `json:"source"`
	// The desired audio sync offset (in nanoseconds).
	// Required: Yes.
	Offset   int `json:"offset"`
	_request `json:",squash"`
	response chan SetSyncOffsetResponse
}

// NewSetSyncOffsetRequest returns a new SetSyncOffsetRequest.
func NewSetSyncOffsetRequest(
	source string,
	offset int,
) SetSyncOffsetRequest {
	return SetSyncOffsetRequest{
		source,
		offset,
		_request{
			ID_:   getMessageID(),
			Type_: "SetSyncOffset",
			err:   make(chan error, 1),
		},
		make(chan SetSyncOffsetResponse, 1),
	}
}

// Send sends the request.
func (r *SetSyncOffsetRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetSyncOffsetResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetSyncOffsetRequest) Receive() (SetSyncOffsetResponse, error) {
	if !r.sent {
		return SetSyncOffsetResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSyncOffsetResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSyncOffsetResponse{}, err
		case <-time.After(receiveTimeout):
			return SetSyncOffsetResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetSyncOffsetRequest) SendReceive(c Client) (SetSyncOffsetResponse, error) {
	if err := r.Send(c); err != nil {
		return SetSyncOffsetResponse{}, err
	}
	return r.Receive()
}

// SetSyncOffsetResponse : Response for SetSyncOffsetRequest.
//
// Since obs-websocket version: 4.2.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#setsyncoffset
type SetSyncOffsetResponse struct {
	_response `json:",squash"`
}

// GetSyncOffsetRequest : Get the audio sync offset of a specified source.
//
// Since obs-websocket version: 4.2.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getsyncoffset
type GetSyncOffsetRequest struct {
	// The name of the source.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan GetSyncOffsetResponse
}

// NewGetSyncOffsetRequest returns a new GetSyncOffsetRequest.
func NewGetSyncOffsetRequest(source string) GetSyncOffsetRequest {
	return GetSyncOffsetRequest{
		source,
		_request{
			ID_:   getMessageID(),
			Type_: "GetSyncOffset",
			err:   make(chan error, 1),
		},
		make(chan GetSyncOffsetResponse, 1),
	}
}

// Send sends the request.
func (r *GetSyncOffsetRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSyncOffsetResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSyncOffsetRequest) Receive() (GetSyncOffsetResponse, error) {
	if !r.sent {
		return GetSyncOffsetResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSyncOffsetResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSyncOffsetResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSyncOffsetResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSyncOffsetRequest) SendReceive(c Client) (GetSyncOffsetResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSyncOffsetResponse{}, err
	}
	return r.Receive()
}

// GetSyncOffsetResponse : Response for GetSyncOffsetRequest.
//
// Since obs-websocket version: 4.2.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getsyncoffset
type GetSyncOffsetResponse struct {
	// The name of the source.
	// Required: Yes.
	Name string `json:"name"`
	// The audio sync offset (in nanoseconds).
	// Required: Yes.
	Offset    int `json:"offset"`
	_response `json:",squash"`
}

// GetSourceSettingsRequest : Get settings of the specified source.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getsourcesettings
type GetSourceSettingsRequest struct {
	// Name of the source item.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Type of the specified source.
	// Useful for type-checking if you expect a specific settings schema.
	// Required: No.
	SourceType string `json:"sourceType"`
	_request   `json:",squash"`
	response   chan GetSourceSettingsResponse
}

// NewGetSourceSettingsRequest returns a new GetSourceSettingsRequest.
func NewGetSourceSettingsRequest(
	sourceName string,
	sourceType string,
) GetSourceSettingsRequest {
	return GetSourceSettingsRequest{
		sourceName,
		sourceType,
		_request{
			ID_:   getMessageID(),
			Type_: "GetSourceSettings",
			err:   make(chan error, 1),
		},
		make(chan GetSourceSettingsResponse, 1),
	}
}

// Send sends the request.
func (r *GetSourceSettingsRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSourceSettingsResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSourceSettingsRequest) Receive() (GetSourceSettingsResponse, error) {
	if !r.sent {
		return GetSourceSettingsResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourceSettingsResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourceSettingsResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSourceSettingsResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSourceSettingsRequest) SendReceive(c Client) (GetSourceSettingsResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSourceSettingsResponse{}, err
	}
	return r.Receive()
}

// GetSourceSettingsResponse : Response for GetSourceSettingsRequest.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getsourcesettings
type GetSourceSettingsResponse struct {
	// Source name.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Type of the specified source.
	// Required: Yes.
	SourceType string `json:"sourceType"`
	// Source settings.
	// Varying between source types.
	// Required: Yes.
	SourceSettings map[string]interface{} `json:"sourceSettings"`
	_response      `json:",squash"`
}

// SetSourceSettingsRequest : Set settings of the specified source.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#setsourcesettings
type SetSourceSettingsRequest struct {
	// Name of the source item.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Type of the specified source.
	// Useful for type-checking to avoid settings a set of settings incompatible with the actual source's type.
	// Required: No.
	SourceType string `json:"sourceType"`
	// Source settings.
	// Varying between source types.
	// Required: Yes.
	SourceSettings map[string]interface{} `json:"sourceSettings"`
	_request       `json:",squash"`
	response       chan SetSourceSettingsResponse
}

// NewSetSourceSettingsRequest returns a new SetSourceSettingsRequest.
func NewSetSourceSettingsRequest(
	sourceName string,
	sourceType string,
	sourceSettings map[string]interface{},
) SetSourceSettingsRequest {
	return SetSourceSettingsRequest{
		sourceName,
		sourceType,
		sourceSettings,
		_request{
			ID_:   getMessageID(),
			Type_: "SetSourceSettings",
			err:   make(chan error, 1),
		},
		make(chan SetSourceSettingsResponse, 1),
	}
}

// Send sends the request.
func (r *SetSourceSettingsRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetSourceSettingsResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetSourceSettingsRequest) Receive() (SetSourceSettingsResponse, error) {
	if !r.sent {
		return SetSourceSettingsResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSourceSettingsResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSourceSettingsResponse{}, err
		case <-time.After(receiveTimeout):
			return SetSourceSettingsResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetSourceSettingsRequest) SendReceive(c Client) (SetSourceSettingsResponse, error) {
	if err := r.Send(c); err != nil {
		return SetSourceSettingsResponse{}, err
	}
	return r.Receive()
}

// SetSourceSettingsResponse : Response for SetSourceSettingsRequest.
//
// Since obs-websocket version: 4.3.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#setsourcesettings
type SetSourceSettingsResponse struct {
	// Source name.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Type of the specified source.
	// Required: Yes.
	SourceType string `json:"sourceType"`
	// Source settings.
	// Varying between source types.
	// Required: Yes.
	SourceSettings map[string]interface{} `json:"sourceSettings"`
	_response      `json:",squash"`
}

// GetTextGDIPlusPropertiesRequest : Get the current properties of a Text GDI Plus source.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#gettextgdiplusproperties
type GetTextGDIPlusPropertiesRequest struct {
	// Name of the scene to retrieve.
	// Defaults to the current scene.
	// Required: No.
	SceneName string `json:"scene-name"`
	// Name of the source.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan GetTextGDIPlusPropertiesResponse
}

// NewGetTextGDIPlusPropertiesRequest returns a new GetTextGDIPlusPropertiesRequest.
func NewGetTextGDIPlusPropertiesRequest(
	sceneName string,
	source string,
) GetTextGDIPlusPropertiesRequest {
	return GetTextGDIPlusPropertiesRequest{
		sceneName,
		source,
		_request{
			ID_:   getMessageID(),
			Type_: "GetTextGDIPlusProperties",
			err:   make(chan error, 1),
		},
		make(chan GetTextGDIPlusPropertiesResponse, 1),
	}
}

// Send sends the request.
func (r *GetTextGDIPlusPropertiesRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetTextGDIPlusPropertiesResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetTextGDIPlusPropertiesRequest) Receive() (GetTextGDIPlusPropertiesResponse, error) {
	if !r.sent {
		return GetTextGDIPlusPropertiesResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetTextGDIPlusPropertiesResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetTextGDIPlusPropertiesResponse{}, err
		case <-time.After(receiveTimeout):
			return GetTextGDIPlusPropertiesResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetTextGDIPlusPropertiesRequest) SendReceive(c Client) (GetTextGDIPlusPropertiesResponse, error) {
	if err := r.Send(c); err != nil {
		return GetTextGDIPlusPropertiesResponse{}, err
	}
	return r.Receive()
}

// GetTextGDIPlusPropertiesResponse : Response for GetTextGDIPlusPropertiesRequest.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#gettextgdiplusproperties
type GetTextGDIPlusPropertiesResponse struct {
	// Text Alignment ("left", "center", "right").
	// Required: Yes.
	Align string `json:"align"`
	// Background color.
	// Required: Yes.
	BkColor int `json:"bk-color"`
	// Background opacity (0-100).
	// Required: Yes.
	BkOpacity int `json:"bk-opacity"`
	// Chat log.
	// Required: Yes.
	Chatlog bool `json:"chatlog"`
	// Chat log lines.
	// Required: Yes.
	ChatlogLines int `json:"chatlog_lines"`
	// Text color.
	// Required: Yes.
	Color int `json:"color"`
	// Extents wrap.
	// Required: Yes.
	Extents bool `json:"extents"`
	// Extents cx.
	// Required: Yes.
	ExtentsCx int `json:"extents_cx"`
	// Extents cy.
	// Required: Yes.
	ExtentsCy int `json:"extents_cy"`
	// File path name.
	// Required: Yes.
	File string `json:"file"`
	// Read text from the specified file.
	// Required: Yes.
	ReadFromFile bool `json:"read_from_file"`
	// Holds data for the font.
	// Ex: `"font": { "face": "Arial", "flags": 0, "size": 150, "style": "" }`.
	// Required: Yes.
	Font map[string]interface{} `json:"font"`
	// Font face.
	// Required: Yes.
	FontFace string `json:"font.face"`
	// Font text styling flag.
	// `Bold=1, Italic=2, Bold Italic=3, Underline=5, Strikeout=8`.
	// Required: Yes.
	FontFlags int `json:"font.flags"`
	// Font text size.
	// Required: Yes.
	FontSize int `json:"font.size"`
	// Font Style (unknown function).
	// Required: Yes.
	FontStyle string `json:"font.style"`
	// Gradient enabled.
	// Required: Yes.
	Gradient bool `json:"gradient"`
	// Gradient color.
	// Required: Yes.
	GradientColor int `json:"gradient_color"`
	// Gradient direction.
	// Required: Yes.
	GradientDir float64 `json:"gradient_dir"`
	// Gradient opacity (0-100).
	// Required: Yes.
	GradientOpacity int `json:"gradient_opacity"`
	// Outline.
	// Required: Yes.
	Outline bool `json:"outline"`
	// Outline color.
	// Required: Yes.
	OutlineColor int `json:"outline_color"`
	// Outline size.
	// Required: Yes.
	OutlineSize int `json:"outline_size"`
	// Outline opacity (0-100).
	// Required: Yes.
	OutlineOpacity int `json:"outline_opacity"`
	// Text content to be displayed.
	// Required: Yes.
	Text string `json:"text"`
	// Text vertical alignment ("top", "center", "bottom").
	// Required: Yes.
	Valign string `json:"valign"`
	// Vertical text enabled.
	// Required: Yes.
	Vertical bool `json:"vertical"`
	// Visibility of the scene item.
	// Required: Yes.
	Render    bool `json:"render"`
	_response `json:",squash"`
}

// SetTextGDIPlusPropertiesRequest : Get the current properties of a Text GDI Plus source.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#settextgdiplusproperties
type SetTextGDIPlusPropertiesRequest struct {
	// Name of the scene to retrieve.
	// Defaults to the current scene.
	// Required: No.
	SceneName string `json:"scene-name"`
	// Name of the source.
	// Required: Yes.
	Source string `json:"source"`
	// Text Alignment ("left", "center", "right").
	// Required: No.
	Align string `json:"align"`
	// Background color.
	// Required: No.
	BkColor int `json:"bk-color"`
	// Background opacity (0-100).
	// Required: No.
	BkOpacity int `json:"bk-opacity"`
	// Chat log.
	// Required: No.
	Chatlog bool `json:"chatlog"`
	// Chat log lines.
	// Required: No.
	ChatlogLines int `json:"chatlog_lines"`
	// Text color.
	// Required: No.
	Color int `json:"color"`
	// Extents wrap.
	// Required: No.
	Extents bool `json:"extents"`
	// Extents cx.
	// Required: No.
	ExtentsCx int `json:"extents_cx"`
	// Extents cy.
	// Required: No.
	ExtentsCy int `json:"extents_cy"`
	// File path name.
	// Required: No.
	File string `json:"file"`
	// Read text from the specified file.
	// Required: No.
	ReadFromFile bool `json:"read_from_file"`
	// Holds data for the font.
	// Ex: `"font": { "face": "Arial", "flags": 0, "size": 150, "style": "" }`.
	// Required: No.
	Font map[string]interface{} `json:"font"`
	// Font face.
	// Required: No.
	FontFace string `json:"font.face"`
	// Font text styling flag.
	// `Bold=1, Italic=2, Bold Italic=3, Underline=5, Strikeout=8`.
	// Required: No.
	FontFlags int `json:"font.flags"`
	// Font text size.
	// Required: No.
	FontSize int `json:"font.size"`
	// Font Style (unknown function).
	// Required: No.
	FontStyle string `json:"font.style"`
	// Gradient enabled.
	// Required: No.
	Gradient bool `json:"gradient"`
	// Gradient color.
	// Required: No.
	GradientColor int `json:"gradient_color"`
	// Gradient direction.
	// Required: No.
	GradientDir float64 `json:"gradient_dir"`
	// Gradient opacity (0-100).
	// Required: No.
	GradientOpacity int `json:"gradient_opacity"`
	// Outline.
	// Required: No.
	Outline bool `json:"outline"`
	// Outline color.
	// Required: No.
	OutlineColor int `json:"outline_color"`
	// Outline size.
	// Required: No.
	OutlineSize int `json:"outline_size"`
	// Outline opacity (0-100).
	// Required: No.
	OutlineOpacity int `json:"outline_opacity"`
	// Text content to be displayed.
	// Required: No.
	Text string `json:"text"`
	// Text vertical alignment ("top", "center", "bottom").
	// Required: No.
	Valign string `json:"valign"`
	// Vertical text enabled.
	// Required: No.
	Vertical bool `json:"vertical"`
	// Visibility of the scene item.
	// Required: No.
	Render   bool `json:"render"`
	_request `json:",squash"`
	response chan SetTextGDIPlusPropertiesResponse
}

// NewSetTextGDIPlusPropertiesRequest returns a new SetTextGDIPlusPropertiesRequest.
func NewSetTextGDIPlusPropertiesRequest(
	sceneName string,
	source string,
	align string,
	bkColor int,
	bkOpacity int,
	chatlog bool,
	chatlogLines int,
	color int,
	extents bool,
	extentsCx int,
	extentsCy int,
	file string,
	readFromFile bool,
	font map[string]interface{},
	fontFace string,
	fontFlags int,
	fontSize int,
	fontStyle string,
	gradient bool,
	gradientColor int,
	gradientDir float64,
	gradientOpacity int,
	outline bool,
	outlineColor int,
	outlineSize int,
	outlineOpacity int,
	text string,
	valign string,
	vertical bool,
	render bool,
) SetTextGDIPlusPropertiesRequest {
	return SetTextGDIPlusPropertiesRequest{
		sceneName,
		source,
		align,
		bkColor,
		bkOpacity,
		chatlog,
		chatlogLines,
		color,
		extents,
		extentsCx,
		extentsCy,
		file,
		readFromFile,
		font,
		fontFace,
		fontFlags,
		fontSize,
		fontStyle,
		gradient,
		gradientColor,
		gradientDir,
		gradientOpacity,
		outline,
		outlineColor,
		outlineSize,
		outlineOpacity,
		text,
		valign,
		vertical,
		render,
		_request{
			ID_:   getMessageID(),
			Type_: "SetTextGDIPlusProperties",
			err:   make(chan error, 1),
		},
		make(chan SetTextGDIPlusPropertiesResponse, 1),
	}
}

// Send sends the request.
func (r *SetTextGDIPlusPropertiesRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetTextGDIPlusPropertiesResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetTextGDIPlusPropertiesRequest) Receive() (SetTextGDIPlusPropertiesResponse, error) {
	if !r.sent {
		return SetTextGDIPlusPropertiesResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetTextGDIPlusPropertiesResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetTextGDIPlusPropertiesResponse{}, err
		case <-time.After(receiveTimeout):
			return SetTextGDIPlusPropertiesResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetTextGDIPlusPropertiesRequest) SendReceive(c Client) (SetTextGDIPlusPropertiesResponse, error) {
	if err := r.Send(c); err != nil {
		return SetTextGDIPlusPropertiesResponse{}, err
	}
	return r.Receive()
}

// SetTextGDIPlusPropertiesResponse : Response for SetTextGDIPlusPropertiesRequest.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#settextgdiplusproperties
type SetTextGDIPlusPropertiesResponse struct {
	_response `json:",squash"`
}

// GetBrowserSourcePropertiesRequest : Get current properties for a Browser Source.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getbrowsersourceproperties
type GetBrowserSourcePropertiesRequest struct {
	// Name of the scene that the source belongs to.
	// Defaults to the current scene.
	// Required: No.
	SceneName string `json:"scene-name"`
	// Name of the source.
	// Required: Yes.
	Source   string `json:"source"`
	_request `json:",squash"`
	response chan GetBrowserSourcePropertiesResponse
}

// NewGetBrowserSourcePropertiesRequest returns a new GetBrowserSourcePropertiesRequest.
func NewGetBrowserSourcePropertiesRequest(
	sceneName string,
	source string,
) GetBrowserSourcePropertiesRequest {
	return GetBrowserSourcePropertiesRequest{
		sceneName,
		source,
		_request{
			ID_:   getMessageID(),
			Type_: "GetBrowserSourceProperties",
			err:   make(chan error, 1),
		},
		make(chan GetBrowserSourcePropertiesResponse, 1),
	}
}

// Send sends the request.
func (r *GetBrowserSourcePropertiesRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetBrowserSourcePropertiesResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetBrowserSourcePropertiesRequest) Receive() (GetBrowserSourcePropertiesResponse, error) {
	if !r.sent {
		return GetBrowserSourcePropertiesResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetBrowserSourcePropertiesResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetBrowserSourcePropertiesResponse{}, err
		case <-time.After(receiveTimeout):
			return GetBrowserSourcePropertiesResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetBrowserSourcePropertiesRequest) SendReceive(c Client) (GetBrowserSourcePropertiesResponse, error) {
	if err := r.Send(c); err != nil {
		return GetBrowserSourcePropertiesResponse{}, err
	}
	return r.Receive()
}

// GetBrowserSourcePropertiesResponse : Response for GetBrowserSourcePropertiesRequest.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getbrowsersourceproperties
type GetBrowserSourcePropertiesResponse struct {
	// Indicates that a local file is in use.
	// Required: Yes.
	IsLocalFile bool `json:"is_local_file"`
	// file path.
	// Required: Yes.
	LocalFile string `json:"local_file"`
	// Url.
	// Required: Yes.
	Url string `json:"url"`
	// CSS to inject.
	// Required: Yes.
	Css string `json:"css"`
	// Width.
	// Required: Yes.
	Width int `json:"width"`
	// Height.
	// Required: Yes.
	Height int `json:"height"`
	// Framerate.
	// Required: Yes.
	FPS int `json:"fps"`
	// Indicates whether the source should be shutdown when not visible.
	// Required: Yes.
	Shutdown bool `json:"shutdown"`
	// Visibility of the scene item.
	// Required: No.
	Render    bool `json:"render"`
	_response `json:",squash"`
}

// SetBrowserSourcePropertiesRequest : Set current properties for a Browser Source.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#setbrowsersourceproperties
type SetBrowserSourcePropertiesRequest struct {
	// Name of the scene that the source belongs to.
	// Defaults to the current scene.
	// Required: No.
	SceneName string `json:"scene-name"`
	// Name of the source.
	// Required: Yes.
	Source string `json:"source"`
	// Indicates that a local file is in use.
	// Required: No.
	IsLocalFile bool `json:"is_local_file"`
	// file path.
	// Required: No.
	LocalFile string `json:"local_file"`
	// Url.
	// Required: No.
	Url string `json:"url"`
	// CSS to inject.
	// Required: No.
	Css string `json:"css"`
	// Width.
	// Required: No.
	Width int `json:"width"`
	// Height.
	// Required: No.
	Height int `json:"height"`
	// Framerate.
	// Required: No.
	FPS int `json:"fps"`
	// Indicates whether the source should be shutdown when not visible.
	// Required: No.
	Shutdown bool `json:"shutdown"`
	// Visibility of the scene item.
	// Required: No.
	Render   bool `json:"render"`
	_request `json:",squash"`
	response chan SetBrowserSourcePropertiesResponse
}

// NewSetBrowserSourcePropertiesRequest returns a new SetBrowserSourcePropertiesRequest.
func NewSetBrowserSourcePropertiesRequest(
	sceneName string,
	source string,
	isLocalFile bool,
	localFile string,
	url string,
	css string,
	width int,
	height int,
	fps int,
	shutdown bool,
	render bool,
) SetBrowserSourcePropertiesRequest {
	return SetBrowserSourcePropertiesRequest{
		sceneName,
		source,
		isLocalFile,
		localFile,
		url,
		css,
		width,
		height,
		fps,
		shutdown,
		render,
		_request{
			ID_:   getMessageID(),
			Type_: "SetBrowserSourceProperties",
			err:   make(chan error, 1),
		},
		make(chan SetBrowserSourcePropertiesResponse, 1),
	}
}

// Send sends the request.
func (r *SetBrowserSourcePropertiesRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetBrowserSourcePropertiesResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetBrowserSourcePropertiesRequest) Receive() (SetBrowserSourcePropertiesResponse, error) {
	if !r.sent {
		return SetBrowserSourcePropertiesResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetBrowserSourcePropertiesResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetBrowserSourcePropertiesResponse{}, err
		case <-time.After(receiveTimeout):
			return SetBrowserSourcePropertiesResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetBrowserSourcePropertiesRequest) SendReceive(c Client) (SetBrowserSourcePropertiesResponse, error) {
	if err := r.Send(c); err != nil {
		return SetBrowserSourcePropertiesResponse{}, err
	}
	return r.Receive()
}

// SetBrowserSourcePropertiesResponse : Response for SetBrowserSourcePropertiesRequest.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#setbrowsersourceproperties
type SetBrowserSourcePropertiesResponse struct {
	_response `json:",squash"`
}

// DeleteSceneItemRequest : Deletes a scene item.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#deletesceneitem
type DeleteSceneItemRequest struct {
	// Name of the scene the source belongs to.
	// Defaults to the current scene.
	// Required: No.
	Scene string `json:"scene"`
	// item to delete (required).
	// Required: Yes.
	Item map[string]interface{} `json:"item"`
	// name of the scene item (prefer `id`, including both is acceptable).
	// Required: Yes.
	ItemName string `json:"item.name"`
	// id of the scene item.
	// Required: Yes.
	ItemID   int `json:"item.id"`
	_request `json:",squash"`
	response chan DeleteSceneItemResponse
}

// NewDeleteSceneItemRequest returns a new DeleteSceneItemRequest.
func NewDeleteSceneItemRequest(
	scene string,
	item map[string]interface{},
	itemName string,
	itemID int,
) DeleteSceneItemRequest {
	return DeleteSceneItemRequest{
		scene,
		item,
		itemName,
		itemID,
		_request{
			ID_:   getMessageID(),
			Type_: "DeleteSceneItem",
			err:   make(chan error, 1),
		},
		make(chan DeleteSceneItemResponse, 1),
	}
}

// Send sends the request.
func (r *DeleteSceneItemRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp DeleteSceneItemResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r DeleteSceneItemRequest) Receive() (DeleteSceneItemResponse, error) {
	if !r.sent {
		return DeleteSceneItemResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return DeleteSceneItemResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return DeleteSceneItemResponse{}, err
		case <-time.After(receiveTimeout):
			return DeleteSceneItemResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r DeleteSceneItemRequest) SendReceive(c Client) (DeleteSceneItemResponse, error) {
	if err := r.Send(c); err != nil {
		return DeleteSceneItemResponse{}, err
	}
	return r.Receive()
}

// DeleteSceneItemResponse : Response for DeleteSceneItemRequest.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#deletesceneitem
type DeleteSceneItemResponse struct {
	_response `json:",squash"`
}

// DuplicateSceneItemRequest : Duplicates a scene item.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#duplicatesceneitem
type DuplicateSceneItemRequest struct {
	// Name of the scene to copy the item from.
	// Defaults to the current scene.
	// Required: No.
	FromScene string `json:"fromScene"`
	// Name of the scene to create the item in.
	// Defaults to the current scene.
	// Required: No.
	ToScene string `json:"toScene"`
	// item to delete (required).
	// Required: Yes.
	Item map[string]interface{} `json:"item"`
	// name of the scene item (prefer `id`, including both is acceptable).
	// Required: Yes.
	ItemName string `json:"item.name"`
	// id of the scene item.
	// Required: Yes.
	ItemID   int `json:"item.id"`
	_request `json:",squash"`
	response chan DuplicateSceneItemResponse
}

// NewDuplicateSceneItemRequest returns a new DuplicateSceneItemRequest.
func NewDuplicateSceneItemRequest(
	fromScene string,
	toScene string,
	item map[string]interface{},
	itemName string,
	itemID int,
) DuplicateSceneItemRequest {
	return DuplicateSceneItemRequest{
		fromScene,
		toScene,
		item,
		itemName,
		itemID,
		_request{
			ID_:   getMessageID(),
			Type_: "DuplicateSceneItem",
			err:   make(chan error, 1),
		},
		make(chan DuplicateSceneItemResponse, 1),
	}
}

// Send sends the request.
func (r *DuplicateSceneItemRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp DuplicateSceneItemResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r DuplicateSceneItemRequest) Receive() (DuplicateSceneItemResponse, error) {
	if !r.sent {
		return DuplicateSceneItemResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return DuplicateSceneItemResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return DuplicateSceneItemResponse{}, err
		case <-time.After(receiveTimeout):
			return DuplicateSceneItemResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r DuplicateSceneItemRequest) SendReceive(c Client) (DuplicateSceneItemResponse, error) {
	if err := r.Send(c); err != nil {
		return DuplicateSceneItemResponse{}, err
	}
	return r.Receive()
}

// DuplicateSceneItemResponse : Response for DuplicateSceneItemRequest.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#duplicatesceneitem
type DuplicateSceneItemResponse struct {
	_response `json:",squash"`
}

// GetSpecialSourcesRequest : Get configured special sources like Desktop Audio and Mic/Aux sources.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getspecialsources
type GetSpecialSourcesRequest struct {
	_request `json:",squash"`
	response chan GetSpecialSourcesResponse
}

// NewGetSpecialSourcesRequest returns a new GetSpecialSourcesRequest.
func NewGetSpecialSourcesRequest() GetSpecialSourcesRequest {
	return GetSpecialSourcesRequest{
		_request{
			ID_:   getMessageID(),
			Type_: "GetSpecialSources",
			err:   make(chan error, 1),
		},
		make(chan GetSpecialSourcesResponse, 1),
	}
}

// Send sends the request.
func (r *GetSpecialSourcesRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSpecialSourcesResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSpecialSourcesRequest) Receive() (GetSpecialSourcesResponse, error) {
	if !r.sent {
		return GetSpecialSourcesResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSpecialSourcesResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSpecialSourcesResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSpecialSourcesResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSpecialSourcesRequest) SendReceive(c Client) (GetSpecialSourcesResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSpecialSourcesResponse{}, err
	}
	return r.Receive()
}

// GetSpecialSourcesResponse : Response for GetSpecialSourcesRequest.
//
// Since obs-websocket version: 4.1.0.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getspecialsources
type GetSpecialSourcesResponse struct {
	// Name of the first Desktop Audio capture source.
	// Required: No.
	Desktop1 string `json:"desktop-1"`
	// Name of the second Desktop Audio capture source.
	// Required: No.
	Desktop2 string `json:"desktop-2"`
	// Name of the first Mic/Aux input source.
	// Required: No.
	Mic1 string `json:"mic-1"`
	// Name of the second Mic/Aux input source.
	// Required: No.
	Mic2 string `json:"mic-2"`
	// NAme of the third Mic/Aux input source.
	// Required: No.
	Mic3      string `json:"mic-3"`
	_response `json:",squash"`
}

// GetSourceFiltersRequest : List filters applied to a source.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getsourcefilters
type GetSourceFiltersRequest struct {
	// Source name.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	_request   `json:",squash"`
	response   chan GetSourceFiltersResponse
}

// NewGetSourceFiltersRequest returns a new GetSourceFiltersRequest.
func NewGetSourceFiltersRequest(sourceName string) GetSourceFiltersRequest {
	return GetSourceFiltersRequest{
		sourceName,
		_request{
			ID_:   getMessageID(),
			Type_: "GetSourceFilters",
			err:   make(chan error, 1),
		},
		make(chan GetSourceFiltersResponse, 1),
	}
}

// Send sends the request.
func (r *GetSourceFiltersRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp GetSourceFiltersResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r GetSourceFiltersRequest) Receive() (GetSourceFiltersResponse, error) {
	if !r.sent {
		return GetSourceFiltersResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourceFiltersResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return GetSourceFiltersResponse{}, err
		case <-time.After(receiveTimeout):
			return GetSourceFiltersResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r GetSourceFiltersRequest) SendReceive(c Client) (GetSourceFiltersResponse, error) {
	if err := r.Send(c); err != nil {
		return GetSourceFiltersResponse{}, err
	}
	return r.Receive()
}

// GetSourceFiltersResponse : Response for GetSourceFiltersRequest.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#getsourcefilters
type GetSourceFiltersResponse struct {
	// List of filters for the specified source.
	// Required: Yes.
	Filters []map[string]interface{} `json:"filters"`
	// Filter type.
	// Required: Yes.
	FiltersType string `json:"filters.*.type"`
	// Filter name.
	// Required: Yes.
	FiltersName string `json:"filters.*.name"`
	// Filter settings.
	// Required: Yes.
	FiltersSettings map[string]interface{} `json:"filters.*.settings"`
	_response       `json:",squash"`
}

// AddFilterToSourceRequest : Add a new filter to a source
// Available source types along with their settings properties are available from `GetSourceTypesList`.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#addfiltertosource
type AddFilterToSourceRequest struct {
	// Name of the source on which the filter is added.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Name of the new filter.
	// Required: Yes.
	FilterName string `json:"filterName"`
	// Filter type.
	// Required: Yes.
	FilterType string `json:"filterType"`
	// Filter settings.
	// Required: Yes.
	FilterSettings map[string]interface{} `json:"filterSettings"`
	_request       `json:",squash"`
	response       chan AddFilterToSourceResponse
}

// NewAddFilterToSourceRequest returns a new AddFilterToSourceRequest.
func NewAddFilterToSourceRequest(
	sourceName string,
	filterName string,
	filterType string,
	filterSettings map[string]interface{},
) AddFilterToSourceRequest {
	return AddFilterToSourceRequest{
		sourceName,
		filterName,
		filterType,
		filterSettings,
		_request{
			ID_:   getMessageID(),
			Type_: "AddFilterToSource",
			err:   make(chan error, 1),
		},
		make(chan AddFilterToSourceResponse, 1),
	}
}

// Send sends the request.
func (r *AddFilterToSourceRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp AddFilterToSourceResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r AddFilterToSourceRequest) Receive() (AddFilterToSourceResponse, error) {
	if !r.sent {
		return AddFilterToSourceResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return AddFilterToSourceResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return AddFilterToSourceResponse{}, err
		case <-time.After(receiveTimeout):
			return AddFilterToSourceResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r AddFilterToSourceRequest) SendReceive(c Client) (AddFilterToSourceResponse, error) {
	if err := r.Send(c); err != nil {
		return AddFilterToSourceResponse{}, err
	}
	return r.Receive()
}

// AddFilterToSourceResponse : Response for AddFilterToSourceRequest.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#addfiltertosource
type AddFilterToSourceResponse struct {
	_response `json:",squash"`
}

// RemoveFilterFromSourceRequest : Remove a filter from a source.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#removefilterfromsource
type RemoveFilterFromSourceRequest struct {
	// Name of the source from which the specified filter is removed.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Name of the filter to remove.
	// Required: Yes.
	FilterName string `json:"filterName"`
	_request   `json:",squash"`
	response   chan RemoveFilterFromSourceResponse
}

// NewRemoveFilterFromSourceRequest returns a new RemoveFilterFromSourceRequest.
func NewRemoveFilterFromSourceRequest(
	sourceName string,
	filterName string,
) RemoveFilterFromSourceRequest {
	return RemoveFilterFromSourceRequest{
		sourceName,
		filterName,
		_request{
			ID_:   getMessageID(),
			Type_: "RemoveFilterFromSource",
			err:   make(chan error, 1),
		},
		make(chan RemoveFilterFromSourceResponse, 1),
	}
}

// Send sends the request.
func (r *RemoveFilterFromSourceRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp RemoveFilterFromSourceResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r RemoveFilterFromSourceRequest) Receive() (RemoveFilterFromSourceResponse, error) {
	if !r.sent {
		return RemoveFilterFromSourceResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return RemoveFilterFromSourceResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return RemoveFilterFromSourceResponse{}, err
		case <-time.After(receiveTimeout):
			return RemoveFilterFromSourceResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r RemoveFilterFromSourceRequest) SendReceive(c Client) (RemoveFilterFromSourceResponse, error) {
	if err := r.Send(c); err != nil {
		return RemoveFilterFromSourceResponse{}, err
	}
	return r.Receive()
}

// RemoveFilterFromSourceResponse : Response for RemoveFilterFromSourceRequest.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#removefilterfromsource
type RemoveFilterFromSourceResponse struct {
	_response `json:",squash"`
}

// ReorderSourceFilterRequest : Move a filter in the chain (absolute index positioning).
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#reordersourcefilter
type ReorderSourceFilterRequest struct {
	// Name of the source to which the filter belongs.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Name of the filter to reorder.
	// Required: Yes.
	FilterName string `json:"filterName"`
	// Desired position of the filter in the chain.
	// Required: Yes.
	NewIndex int `json:"newIndex"`
	_request `json:",squash"`
	response chan ReorderSourceFilterResponse
}

// NewReorderSourceFilterRequest returns a new ReorderSourceFilterRequest.
func NewReorderSourceFilterRequest(
	sourceName string,
	filterName string,
	newIndex int,
) ReorderSourceFilterRequest {
	return ReorderSourceFilterRequest{
		sourceName,
		filterName,
		newIndex,
		_request{
			ID_:   getMessageID(),
			Type_: "ReorderSourceFilter",
			err:   make(chan error, 1),
		},
		make(chan ReorderSourceFilterResponse, 1),
	}
}

// Send sends the request.
func (r *ReorderSourceFilterRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp ReorderSourceFilterResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r ReorderSourceFilterRequest) Receive() (ReorderSourceFilterResponse, error) {
	if !r.sent {
		return ReorderSourceFilterResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return ReorderSourceFilterResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return ReorderSourceFilterResponse{}, err
		case <-time.After(receiveTimeout):
			return ReorderSourceFilterResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r ReorderSourceFilterRequest) SendReceive(c Client) (ReorderSourceFilterResponse, error) {
	if err := r.Send(c); err != nil {
		return ReorderSourceFilterResponse{}, err
	}
	return r.Receive()
}

// ReorderSourceFilterResponse : Response for ReorderSourceFilterRequest.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#reordersourcefilter
type ReorderSourceFilterResponse struct {
	_response `json:",squash"`
}

// MoveSourceFilterRequest : Move a filter in the chain (relative positioning).
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#movesourcefilter
type MoveSourceFilterRequest struct {
	// Name of the source to which the filter belongs.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Name of the filter to reorder.
	// Required: Yes.
	FilterName string `json:"filterName"`
	// How to move the filter around in the source's filter chain.
	// Either "up", "down", "top" or "bottom".
	// Required: Yes.
	MovementType string `json:"movementType"`
	_request     `json:",squash"`
	response     chan MoveSourceFilterResponse
}

// NewMoveSourceFilterRequest returns a new MoveSourceFilterRequest.
func NewMoveSourceFilterRequest(
	sourceName string,
	filterName string,
	movementType string,
) MoveSourceFilterRequest {
	return MoveSourceFilterRequest{
		sourceName,
		filterName,
		movementType,
		_request{
			ID_:   getMessageID(),
			Type_: "MoveSourceFilter",
			err:   make(chan error, 1),
		},
		make(chan MoveSourceFilterResponse, 1),
	}
}

// Send sends the request.
func (r *MoveSourceFilterRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp MoveSourceFilterResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r MoveSourceFilterRequest) Receive() (MoveSourceFilterResponse, error) {
	if !r.sent {
		return MoveSourceFilterResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return MoveSourceFilterResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return MoveSourceFilterResponse{}, err
		case <-time.After(receiveTimeout):
			return MoveSourceFilterResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r MoveSourceFilterRequest) SendReceive(c Client) (MoveSourceFilterResponse, error) {
	if err := r.Send(c); err != nil {
		return MoveSourceFilterResponse{}, err
	}
	return r.Receive()
}

// MoveSourceFilterResponse : Response for MoveSourceFilterRequest.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#movesourcefilter
type MoveSourceFilterResponse struct {
	_response `json:",squash"`
}

// SetSourceFilterSettingsRequest : Update settings of a filter.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#setsourcefiltersettings
type SetSourceFilterSettingsRequest struct {
	// Name of the source to which the filter belongs.
	// Required: Yes.
	SourceName string `json:"sourceName"`
	// Name of the filter to reconfigure.
	// Required: Yes.
	FilterName string `json:"filterName"`
	// New settings.
	// These will be merged to the current filter settings.
	// Required: Yes.
	FilterSettings map[string]interface{} `json:"filterSettings"`
	_request       `json:",squash"`
	response       chan SetSourceFilterSettingsResponse
}

// NewSetSourceFilterSettingsRequest returns a new SetSourceFilterSettingsRequest.
func NewSetSourceFilterSettingsRequest(
	sourceName string,
	filterName string,
	filterSettings map[string]interface{},
) SetSourceFilterSettingsRequest {
	return SetSourceFilterSettingsRequest{
		sourceName,
		filterName,
		filterSettings,
		_request{
			ID_:   getMessageID(),
			Type_: "SetSourceFilterSettings",
			err:   make(chan error, 1),
		},
		make(chan SetSourceFilterSettingsResponse, 1),
	}
}

// Send sends the request.
func (r *SetSourceFilterSettingsRequest) Send(c Client) error {
	if r.sent {
		return ErrAlreadySent
	}
	future, err := c.sendRequest(r)
	if err != nil {
		return err
	}
	r.sent = true
	go func() {
		m := <-future
		var resp SetSourceFilterSettingsResponse
		if err = mapToStruct(m, &resp); err != nil {
			r.err <- err
		} else if resp.Status() != StatusOK {
			r.err <- errors.New(resp.Error())
		} else {
			r.response <- resp
		}
	}()
	return nil
}

// Receive waits for the response.
func (r SetSourceFilterSettingsRequest) Receive() (SetSourceFilterSettingsResponse, error) {
	if !r.sent {
		return SetSourceFilterSettingsResponse{}, ErrNotSent
	}
	if receiveTimeout == 0 {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSourceFilterSettingsResponse{}, err
		}
	} else {
		select {
		case resp := <-r.response:
			return resp, nil
		case err := <-r.err:
			return SetSourceFilterSettingsResponse{}, err
		case <-time.After(receiveTimeout):
			return SetSourceFilterSettingsResponse{}, ErrReceiveTimeout
		}
	}
}

// SendReceive sends the request then immediately waits for the response.
func (r SetSourceFilterSettingsRequest) SendReceive(c Client) (SetSourceFilterSettingsResponse, error) {
	if err := r.Send(c); err != nil {
		return SetSourceFilterSettingsResponse{}, err
	}
	return r.Receive()
}

// SetSourceFilterSettingsResponse : Response for SetSourceFilterSettingsRequest.
//
// Since obs-websocket version: Unreleased.
//
// https://github.com/Palakis/obs-websocket/blob/4.3-maintenance/docs/generated/protocol.md#setsourcefiltersettings
type SetSourceFilterSettingsResponse struct {
	_response `json:",squash"`
}
